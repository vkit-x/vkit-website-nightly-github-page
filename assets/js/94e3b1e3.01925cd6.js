"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[768],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,s=r(e,["components","mdxType","originalType","parentName"]),k=d(n),c=i,u=k["".concat(p,".").concat(c)]||k[c]||m[c]||l;return n?a.createElement(u,o(o({ref:t},s),{},{components:n})):a.createElement(u,o({ref:t},s))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=k;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var d=2;d<l;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},6012:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return p},metadata:function(){return d},toc:function(){return s},default:function(){return k}});var a=n(3117),i=n(102),l=(n(7294),n(3905)),o=["components"],r={},p="Labeled Data Type",d={unversionedId:"utility/label",id:"utility/label",title:"Labeled Data Type",description:"Point",source:"@site/docs/utility/label.md",sourceDirName:"utility",slug:"/utility/label",permalink:"/utility/label",editUrl:"https://github.com/vkit-x/vkit/edit/master/website/docs/utility/label.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Image Type",permalink:"/utility/image"}},s=[{value:"Point",id:"point",children:[{value:"<code>self.clone</code>",id:"selfclone",children:[],level:3},{value:"<code>self.to_xy_pair</code>",id:"selfto_xy_pair",children:[],level:3},{value:"<code>self.to_clipped_point</code>",id:"selfto_clipped_point",children:[],level:3},{value:"<code>self.to_resized_point</code>",id:"selfto_resized_point",children:[],level:3}],level:2},{value:"PointList",id:"pointlist",children:[{value:"<code>PointList.from_np_array</code>",id:"pointlistfrom_np_array",children:[],level:3},{value:"<code>PointList.from_xy_pairs</code>",id:"pointlistfrom_xy_pairs",children:[],level:3},{value:"<code>PointList.from_flatten_xy_pairs</code>",id:"pointlistfrom_flatten_xy_pairs",children:[],level:3},{value:"<code>PointList.from_point</code>",id:"pointlistfrom_point",children:[],level:3},{value:"<code>self.clone</code>",id:"selfclone-1",children:[],level:3},{value:"<code>self.to_xy_pairs</code>",id:"selfto_xy_pairs",children:[],level:3},{value:"<code>self.to_np_array</code>",id:"selfto_np_array",children:[],level:3},{value:"<code>self.to_clipped_points</code>",id:"selfto_clipped_points",children:[],level:3},{value:"<code>self.to_resized_points</code>",id:"selfto_resized_points",children:[],level:3}],level:2},{value:"Box",id:"box",children:[{value:"<code>self.clone</code>",id:"selfclone-2",children:[],level:3},{value:"<code>self.to_clipped_box</code>",id:"selfto_clipped_box",children:[],level:3},{value:"<code>self.extract_image</code>",id:"selfextract_image",children:[],level:3}],level:2},{value:"Polygon",id:"polygon",children:[{value:"<code>Polygon.from_np_array</code>",id:"polygonfrom_np_array",children:[],level:3},{value:"<code>Polygon.from_xy_pairs</code>",id:"polygonfrom_xy_pairs",children:[],level:3},{value:"<code>Polygon.from_flatten_xy_pairs</code>",id:"polygonfrom_flatten_xy_pairs",children:[],level:3},{value:"<code>self.to_xy_pairs</code>, <code>self.to_np_array</code> and <code>self.to_clipped_points</code>",id:"selfto_xy_pairs-selfto_np_array-and-selfto_clipped_points",children:[],level:3},{value:"<code>self.to_clipped_polygon</code>",id:"selfto_clipped_polygon",children:[],level:3},{value:"<code>self.to_bounding_box_with_np_points</code>",id:"selfto_bounding_box_with_np_points",children:[],level:3},{value:"<code>self.to_bounding_box</code>",id:"selfto_bounding_box",children:[],level:3},{value:"<code>self.to_resized_polygon</code>",id:"selfto_resized_polygon",children:[],level:3},{value:"<code>self.clone</code>",id:"selfclone-3",children:[],level:3}],level:2},{value:"TextPolygon",id:"textpolygon",children:[{value:"<code>self.to_resized_text_polygon</code>",id:"selfto_resized_text_polygon",children:[],level:3}],level:2},{value:"ImageMask",id:"imagemask",children:[{value:"<code>ImageMask.from_shape</code>",id:"imagemaskfrom_shape",children:[],level:3},{value:"<code>ImageMask.from_shape_and_polygons</code>",id:"imagemaskfrom_shape_and_polygons",children:[],level:3},{value:"<code>ImageMask.from_image_and_polygons</code>",id:"imagemaskfrom_image_and_polygons",children:[],level:3},{value:"<code>self.to_resized_image_mask</code>",id:"selfto_resized_image_mask",children:[],level:3},{value:"<code>self.clone</code>",id:"selfclone-4",children:[],level:3}],level:2},{value:"ImageScoreMap",id:"imagescoremap",children:[{value:"<code>ImageScoreMap.from_image_mask</code>",id:"imagescoremapfrom_image_mask",children:[],level:3},{value:"<code>ImageScoreMap.from_shape_and_polygon_value_pairs</code>",id:"imagescoremapfrom_shape_and_polygon_value_pairs",children:[],level:3},{value:"<code>ImageScoreMap.from_image_and_polygon_value_pairs</code>",id:"imagescoremapfrom_image_and_polygon_value_pairs",children:[],level:3}],level:2}],m={toc:s};function k(e){var t=e.components,n=(0,i.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"labeled-data-type"},"Labeled Data Type"),(0,l.kt)("h2",{id:"point"},"Point"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import Point\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Point")," represents a point on 2D plane\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.define\nclass Point:\n    y: int\n    x: int\n")),(0,l.kt)("p",null,"Methods available in ",(0,l.kt)("inlineCode",{parentName:"p"},"Point"),":"),(0,l.kt)("h3",{id:"selfclone"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.clone")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns a copy of the object"),(0,l.kt)("h3",{id:"selfto_xy_pair"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_xy_pair")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns a tuple as ",(0,l.kt)("inlineCode",{parentName:"p"},"(x, y)")),(0,l.kt)("h3",{id:"selfto_clipped_point"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_clipped_point")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image")),(0,l.kt)("p",null,"Generates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"Point"),", ensure no positional overflow/underflow would take place via clip operation"),(0,l.kt)("h3",{id:"selfto_resized_point"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_resized_point")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image, resized_height: int, resized_width: int")),(0,l.kt)("p",null,"Generates new ",(0,l.kt)("inlineCode",{parentName:"p"},"Point")," based on resized target image's height and width. ",(0,l.kt)("inlineCode",{parentName:"p"},"image")," represents the original image, ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_height")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_width")," is the desired resized image's height and width respectively"),(0,l.kt)("h2",{id:"pointlist"},"PointList"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import PointList\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," is used to represent a list of ",(0,l.kt)("inlineCode",{parentName:"p"},"Point"),"\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class PointList(List[Point]):\n    ...\n")),(0,l.kt)("p",null,"Methods available in ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList"),"\uff1a"),(0,l.kt)("h3",{id:"pointlistfrom_np_array"},(0,l.kt)("inlineCode",{parentName:"h3"},"PointList.from_np_array")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"np_points: np.ndarray")),(0,l.kt)("p",null,"Converts a numpy array with shape ",(0,l.kt)("inlineCode",{parentName:"p"},"(*, 2)")," (",(0,l.kt)("inlineCode",{parentName:"p"},"[(x, y), ...]"),") into a ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," object"),(0,l.kt)("h3",{id:"pointlistfrom_xy_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"PointList.from_xy_pairs")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"xy_pairs: Iterable[Tuple[int, int]]")),(0,l.kt)("p",null,"Converts an ",(0,l.kt)("inlineCode",{parentName:"p"},"Iterable[Tuple[int, int]]")," into a ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," object"),(0,l.kt)("h3",{id:"pointlistfrom_flatten_xy_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"PointList.from_flatten_xy_pairs")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"flatten_xy_pairs: Sequence[int]")),(0,l.kt)("p",null,"Similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList.from_xy_pairs"),", however accepts the input in the format of ",(0,l.kt)("inlineCode",{parentName:"p"},"[x0, y0, x1, y1, ...]")),(0,l.kt)("h3",{id:"pointlistfrom_point"},(0,l.kt)("inlineCode",{parentName:"h3"},"PointList.from_point")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"point: Point")),(0,l.kt)("p",null,"Returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," which contains the specified ",(0,l.kt)("inlineCode",{parentName:"p"},"point")," object alone"),(0,l.kt)("h3",{id:"selfclone-1"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.clone")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns a copy of the object"),(0,l.kt)("h3",{id:"selfto_xy_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_xy_pairs")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Converts the ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," into ",(0,l.kt)("inlineCode",{parentName:"p"},"List[Tuple[int, int]]"),", aka the reverse operation of ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList.from_xy_pairs")),(0,l.kt)("h3",{id:"selfto_np_array"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_np_array")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Converts the ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," into a numpy array, aka the reverse operation of ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList.from_np_array")),(0,l.kt)("h3",{id:"selfto_clipped_points"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_clipped_points")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image")),(0,l.kt)("p",null,"Generates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," object, ensures no positional overflow/underflow via clip operation"),(0,l.kt)("h3",{id:"selfto_resized_points"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_resized_points")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image, resized_height: int, resized_width: int")),(0,l.kt)("p",null,"Generates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," based on resized target image's height and width. ",(0,l.kt)("inlineCode",{parentName:"p"},"image")," represents the original image, ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_height")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_width")," is the desired resized image's height and width respectively"),(0,l.kt)("h2",{id:"box"},"Box"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import Box\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Box")," is used to represent rectangular labeled area which is horizontal and vertical"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.define\nclass Box:\n    up: int\n    down: int\n    left: int\n    right: int\n")),(0,l.kt)("p",null,"Explanation:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"up")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"left")," represents the coordinate of the top left corner"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"up")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"right")," represents the coordinate of the top right corner"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"down")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"left")," represents the coordinate of the bottom left corner"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"down")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"right")," represents the coordinate of the bottom right corner"),(0,l.kt)("li",{parentName:"ul"},"Box is therefore a rectangular enclosed by the 4 points mentioned above")),(0,l.kt)("p",null,"Attributes of ",(0,l.kt)("inlineCode",{parentName:"p"},"Box"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": type ",(0,l.kt)("inlineCode",{parentName:"li"},"int")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"width"),": type ",(0,l.kt)("inlineCode",{parentName:"li"},"int")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"shape"),": (height, width), type ",(0,l.kt)("inlineCode",{parentName:"li"},"Tuple[int, int]"))),(0,l.kt)("p",null,"Methods available for ",(0,l.kt)("inlineCode",{parentName:"p"},"Box"),":"),(0,l.kt)("h3",{id:"selfclone-2"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.clone")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Creates a copy of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Box")),(0,l.kt)("h3",{id:"selfto_clipped_box"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_clipped_box")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image")),(0,l.kt)("p",null,"Generates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"Box")," object, ensures no positional overflow/underflow via clip operation"),(0,l.kt)("h3",{id:"selfextract_image"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.extract_image")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image")),(0,l.kt)("p",null,"Extracts part of a ",(0,l.kt)("inlineCode",{parentName:"p"},"image")," surrounded by a ",(0,l.kt)("inlineCode",{parentName:"p"},"Box")," object, returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"Image")," object. Note that this method will not generate a new numpy array, therefore explicit ",(0,l.kt)("inlineCode",{parentName:"p"},"clone")," is required"),(0,l.kt)("h2",{id:"polygon"},"Polygon"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import Polygon\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Polygon")," represents a polygon shaped area"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.define\nclass Polygon:\n    points: PointList\n")),(0,l.kt)("p",null,"Methods available for ",(0,l.kt)("inlineCode",{parentName:"p"},"Polygon"),":"),(0,l.kt)("h3",{id:"polygonfrom_np_array"},(0,l.kt)("inlineCode",{parentName:"h3"},"Polygon.from_np_array")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"np_points: np.ndarray")),(0,l.kt)("p",null,"Calls ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList.from_np_array")," to generate ",(0,l.kt)("inlineCode",{parentName:"p"},"self.points")),(0,l.kt)("h3",{id:"polygonfrom_xy_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"Polygon.from_xy_pairs")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"xy_pairs")),(0,l.kt)("p",null,"Calls ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList.from_xy_pairs")," to generate ",(0,l.kt)("inlineCode",{parentName:"p"},"self.points")),(0,l.kt)("h3",{id:"polygonfrom_flatten_xy_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"Polygon.from_flatten_xy_pairs")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"xy_pairs: Sequence[int]")),(0,l.kt)("p",null,"Calls ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList.from_flatten_xy_pairs")," to generate",(0,l.kt)("inlineCode",{parentName:"p"},"self.points")),(0,l.kt)("h3",{id:"selfto_xy_pairs-selfto_np_array-and-selfto_clipped_points"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_xy_pairs"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_np_array")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_clipped_points")),(0,l.kt)("p",null,"Will all call methods defined in ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")," with the same name and output in the same type"),(0,l.kt)("h3",{id:"selfto_clipped_polygon"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_clipped_polygon")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Polygon")," while ",(0,l.kt)("inlineCode",{parentName:"p"},"self.to_clipped_points()")," returns ",(0,l.kt)("inlineCode",{parentName:"p"},"PointList")),(0,l.kt)("h3",{id:"selfto_bounding_box_with_np_points"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_bounding_box_with_np_points")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"shift_np_points: bool = False")),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Tuple[Box, np.ndarray]"),", which is the bounding ",(0,l.kt)("inlineCode",{parentName:"p"},"Box")," object and ",(0,l.kt)("inlineCode",{parentName:"p"},"self.points")," converted to a numpy array. If ",(0,l.kt)("inlineCode",{parentName:"p"},"shift_np_points")," was set to ",(0,l.kt)("inlineCode",{parentName:"p"},"True"),", the point that was closest to origin will be the new origin (aka. shift to ",(0,l.kt)("inlineCode",{parentName:"p"},"(0, 0)"),")"),(0,l.kt)("h3",{id:"selfto_bounding_box"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_bounding_box")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns the ",(0,l.kt)("inlineCode",{parentName:"p"},"Box")," explained in ",(0,l.kt)("inlineCode",{parentName:"p"},"self.to_bounding_box_with_np_points")),(0,l.kt)("h3",{id:"selfto_resized_polygon"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_resized_polygon")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image, resized_height: int, resized_width: int")),(0,l.kt)("p",null,"Generates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"Polygon")," based on resized target image's height and width. ",(0,l.kt)("inlineCode",{parentName:"p"},"image")," represents the original image, ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_height")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_width")," is the desired resized image's height and width respectively"),(0,l.kt)("h3",{id:"selfclone-3"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.clone")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns a copy of the object"),(0,l.kt)("h2",{id:"textpolygon"},"TextPolygon"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import TextPolygon\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"TextPolygon")," represents a polygon area tagged with text label:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.define\nclass TextPolygon:\n    text: str\n    polygon: Polygon\n    meta: Optional[Dict[str, Any]] = None\n")),(0,l.kt)("p",null,"Explanation:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"text"),": must not be empty or ",(0,l.kt)("inlineCode",{parentName:"li"},"None")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"meta"),": Optional, can be used to keep other metadata")),(0,l.kt)("p",null,"Methods available for ",(0,l.kt)("inlineCode",{parentName:"p"},"TextPolygon"),":"),(0,l.kt)("h3",{id:"selfto_resized_text_polygon"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_resized_text_polygon")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image, resized_height: int, resized_width: int")),(0,l.kt)("p",null,"Generates a new ",(0,l.kt)("inlineCode",{parentName:"p"},"TextPolygon")," based on resized target image's height and width. ",(0,l.kt)("inlineCode",{parentName:"p"},"image")," represents the original image, ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_height")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"resized_width")," is the desired resized image's height and width respectively"),(0,l.kt)("h2",{id:"imagemask"},"ImageMask"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import ImageMask\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask")," represents a mask label:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.define\nclass ImageMask:\n    mat: np.ndarray\n")),(0,l.kt)("p",null,"Explanation:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mat")," fulfills ",(0,l.kt)("inlineCode",{parentName:"li"},"ndim = 2")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"dtype = np.uint8"))),(0,l.kt)("p",null,"Attributes of ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": type ",(0,l.kt)("inlineCode",{parentName:"li"},"int")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"width"),": type ",(0,l.kt)("inlineCode",{parentName:"li"},"int")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"shape"),": (height, width), type ",(0,l.kt)("inlineCode",{parentName:"li"},"Tuple[int, int]"))),(0,l.kt)("p",null,"Methods available for ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask"),":"),(0,l.kt)("h3",{id:"imagemaskfrom_shape"},(0,l.kt)("inlineCode",{parentName:"h3"},"ImageMask.from_shape")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"height: int, width: int")),(0,l.kt)("p",null,"Initialize ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask")," from ",(0,l.kt)("inlineCode",{parentName:"p"},"shape"),", while all elements in ",(0,l.kt)("inlineCode",{parentName:"p"},"mat")," will be initialized to ",(0,l.kt)("inlineCode",{parentName:"p"},"0")),(0,l.kt)("h3",{id:"imagemaskfrom_shape_and_polygons"},(0,l.kt)("inlineCode",{parentName:"h3"},"ImageMask.from_shape_and_polygons")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"height: int, width: int, polygons: Iterable[Polygon], mode: ImageMaskPolygonsMergeMode = ImageMaskPolygonsMergeMode.UNION")),(0,l.kt)("p",null,"Initialize ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask")," from ",(0,l.kt)("inlineCode",{parentName:"p"},"shape")," and one or more ",(0,l.kt)("inlineCode",{parentName:"p"},"Polygon"),"."),(0,l.kt)("p",null,"The default ",(0,l.kt)("inlineCode",{parentName:"p"},"mode == ImageMaskPolygonsMergeMode.UNION")," sets the areas covered by any of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Polygon")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),"; If ",(0,l.kt)("inlineCode",{parentName:"p"},"mode == ImageMaskPolygonsMergeMode.DISTINCT"),", only sets non-overlapping areas to ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),"; Similarly, if ",(0,l.kt)("inlineCode",{parentName:"p"},"mode == ImageMaskPolygonsMergeMode.INTERSECTION"),", only sets areas where overlap exist to ",(0,l.kt)("inlineCode",{parentName:"p"},"1")),(0,l.kt)("h3",{id:"imagemaskfrom_image_and_polygons"},(0,l.kt)("inlineCode",{parentName:"h3"},"ImageMask.from_image_and_polygons")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image, polygons: Iterable[Polygon], mode: ImageMaskPolygonsMergeMode = ImageMaskPolygonsMergeMode.UNION")),(0,l.kt)("p",null,"Similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask.from_shape_and_polygons"),", however ",(0,l.kt)("inlineCode",{parentName:"p"},"image.shape")," will be used instead"),(0,l.kt)("h3",{id:"selfto_resized_image_mask"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.to_resized_image_mask")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"height: int, width: int, cv_resize_interpolation: int = cv.INTER_NEAREST_EXACT")),(0,l.kt)("p",null,"resize the height and width of the mask"),(0,l.kt)("h3",{id:"selfclone-4"},(0,l.kt)("inlineCode",{parentName:"h3"},"self.clone")),(0,l.kt)("p",null,"Parameters: None"),(0,l.kt)("p",null,"Returns a copy of the object"),(0,l.kt)("h2",{id:"imagescoremap"},"ImageScoreMap"),(0,l.kt)("p",null,"Import statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from vkit.label.type import ImageScoreMap\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ImageScoreMap")," represents a score map\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"@attr.define\nclass ImageScoreMap:\n    mat: np.ndarray\n")),(0,l.kt)("p",null,"Explanation:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mat")," fulfills ",(0,l.kt)("inlineCode",{parentName:"li"},"ndim = 2")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"dtype = np.float32"))),(0,l.kt)("p",null,"Attributes of ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageScoreMap"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"height"),": type ",(0,l.kt)("inlineCode",{parentName:"li"},"int")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"width"),": type ",(0,l.kt)("inlineCode",{parentName:"li"},"int")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"shape"),": (height, width), type ",(0,l.kt)("inlineCode",{parentName:"li"},"Tuple[int, int]"))),(0,l.kt)("p",null,"Methods available in ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageScoreMap"),"\uff1a"),(0,l.kt)("h3",{id:"imagescoremapfrom_image_mask"},(0,l.kt)("inlineCode",{parentName:"h3"},"ImageScoreMap.from_image_mask")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image_mask: ImageMask")),(0,l.kt)("p",null,"Converts from a ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageMask")," to a ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageScoreMap")),(0,l.kt)("h3",{id:"imagescoremapfrom_shape_and_polygon_value_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"ImageScoreMap.from_shape_and_polygon_value_pairs")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"height: int, width: int, polygon_value_pairs: Iterable[Tuple[Polygon, float]]")),(0,l.kt)("p",null,"Initialize a ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageScoreMap")," with the provided height and width, the float value in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Tuple[Polygon, float]")," will be used as the score"),(0,l.kt)("h3",{id:"imagescoremapfrom_image_and_polygon_value_pairs"},(0,l.kt)("inlineCode",{parentName:"h3"},"ImageScoreMap.from_image_and_polygon_value_pairs")),(0,l.kt)("p",null,"Parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"image: Image, polygon_value_pairs: Iterable[Tuple[Polygon, float]]")),(0,l.kt)("p",null,"Similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"ImageScoreMap.from_shape_and_polygon_value_pairs"),", however ",(0,l.kt)("inlineCode",{parentName:"p"},"image.shape")," will be used instead for the height and width"))}k.isMDXComponent=!0}}]);